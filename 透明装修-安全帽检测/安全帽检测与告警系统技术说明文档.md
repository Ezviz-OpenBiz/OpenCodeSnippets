# å®‰å…¨å¸½æ£€æµ‹ä¸å‘Šè­¦ç³»ç»ŸæŠ€æœ¯è¯´æ˜æ–‡æ¡£

# æ¦‚è¿°

æœ¬ç³»ç»Ÿæ˜¯ä¸€ä¸ªé›†æˆäº‘ç«¯æŠ“æ‹ã€AIå®‰å…¨å¸½è¯†åˆ«ã€è¯­éŸ³å‘Šè­¦åŠäº‘ç«¯æ–‡ä»¶ç®¡ç†çš„ç»¼åˆæµ‹è¯•ç¨‹åºã€‚é€šè¿‡è°ƒç”¨äº‘å¹³å°æ¥å£å®ç°è®¾å¤‡æŠ“æ‹ã€å®‰å…¨çŠ¶æ€è¯†åˆ«ï¼Œå¹¶åœ¨æ£€æµ‹åˆ°è¿è§„æƒ…å†µæ—¶è§¦å‘è¯­éŸ³å‘Šè­¦ï¼ŒåŒæ—¶æ”¯æŒéå‘Šè­¦å›¾ç‰‡çš„äº‘ç«¯è‡ªåŠ¨æ¸…ç†ï¼Œä»¥ä¼˜åŒ–å­˜å‚¨èµ„æºä½¿ç”¨ã€‚

## ç¯å¢ƒä¾èµ–

### è¿è¡Œç¯å¢ƒ
- Python 3.6+
- ç½‘ç»œè¿æ¥ï¼ˆéœ€è®¿é—®äº‘æœåŠ¡æ¥å£ï¼‰

### ä¾èµ–åº“
```
requests>=2.25.1
python-dotenv>=0.19.0
```

### ç¯å¢ƒé…ç½®
é€šè¿‡ `.env` æ–‡ä»¶æˆ–ç³»ç»Ÿç¯å¢ƒå˜é‡é…ç½®å‚æ•°ï¼Œä»£ç å®ç°å¦‚ä¸‹ï¼š

```python
# åŠ è½½ç¯å¢ƒå˜é‡
load_dotenv()

# é…ç½®æ—¥å¿—
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("real_process_test.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# è¯»å–å›ºå®šé…ç½®
YS_ACCESS_TOKEN = os.getenv("YS_ACCESS_TOKEN")
DEVICE_SERIAL = os.getenv("DEVICE_SERIAL", "BF7683347")
CHANNEL_NO = int(os.getenv("CAPTURE_CHANNEL_NO", "1"))
PROJECT_ID = os.getenv("CAPTURE_PROJECT_ID")
VOICE_FILE_URL = os.getenv("VOICE_FILE_URL")

# æ–°å¢é…ç½®ï¼šæ˜¯å¦å¯ç”¨äº‘ç«¯å›¾ç‰‡æ¸…ç†
ENABLE_CLOUD_CLEANUP = os.getenv("ENABLE_CLOUD_CLEANUP", "1").lower() in ("1", "true", "yes")

# æ¥å£URL
CAPTURE_URL = "https://open.ys7.com/api/open/cloud/v1/capture/save"
HELMET_DETECT_URL = "https://open.ys7.com/api/service/intelligence/algo/analysis/helmet_detection"
VOICE_SEND_URL = "https://open.ys7.com/api/lapp/voice/sendonce"
# æ–°å¢åˆ é™¤æ–‡ä»¶æ¥å£URL
DELETE_FILE_URL = "https://open.ys7.com/api/open/cloud/v1/file"
```

| é…ç½®é¡¹                 | è¯´æ˜                       | æ˜¯å¦å¿…éœ€ | é»˜è®¤å€¼                  |
| ---------------------- | -------------------------- | -------- | ----------------------- |
| `YS_ACCESS_TOKEN`      | äº‘æœåŠ¡è®¿é—®ä»¤ç‰Œ             | æ˜¯       | -                       |
| `DEVICE_SERIAL`        | è®¾å¤‡åºåˆ—å·                 | æ˜¯       | è®¾å¤‡åºåˆ—å·              |
| `CAPTURE_CHANNEL_NO`   | æŠ“æ‹é€šé“å·                 | å¦       | `1`                     |
| `CAPTURE_PROJECT_ID`   | é¡¹ç›®ID                     | æ˜¯       | -                       |
| `VOICE_FILE_URL`       | è¯­éŸ³å‘Šè­¦æ–‡ä»¶URL            | å¦       | -                       |
| `ENABLE_CLOUD_CLEANUP` | æ˜¯å¦å¯ç”¨äº‘ç«¯æ–‡ä»¶æ¸…ç†       | å¦       | `true`                  |
| `STORAGE_BASE_PATH`    | æœ¬åœ°å›¾ç‰‡å­˜å‚¨è·¯å¾„           | å¦       | `./real_capture_images` |
| `ALERT_THRESHOLD`      | å‘Šè­¦è§¦å‘é˜ˆå€¼ï¼ˆæœªä½©æˆ´äººæ•°ï¼‰ | å¦       | `1`                     |

## åŠŸèƒ½æ¨¡å—è¯´æ˜

### 1. äº‘ç«¯æ–‡ä»¶ç®¡ç†å™¨ï¼ˆCloudFileManagerï¼‰

è´Ÿè´£äº‘ç«¯æ–‡ä»¶çš„åˆ é™¤æ“ä½œï¼Œæä¾›äº‘ç«¯å­˜å‚¨èµ„æºç®¡ç†èƒ½åŠ›ã€‚

#### å®Œæ•´ä»£ç å®ç°
```python
class CloudFileManager:
    """äº‘ç«¯æ–‡ä»¶ç®¡ç†å™¨ - è´Ÿè´£æ–‡ä»¶çš„åˆ›å»ºå’Œæ¸…ç†"""

    def __init__(self, access_token, project_id):
        self.access_token = access_token
        self.project_id = project_id

    def delete_cloud_file(self, file_id: str) -> bool:
        """
        åˆ é™¤äº‘ç«¯æ–‡ä»¶
        Args:
            file_id: è¦åˆ é™¤çš„æ–‡ä»¶ID
        Returns:
            åˆ é™¤æ˜¯å¦æˆåŠŸ
        """
        print(f"ğŸ—‘ï¸  å°è¯•åˆ é™¤äº‘ç«¯æ–‡ä»¶: {file_id}")
        try:
            # å‡†å¤‡åˆ é™¤è¯·æ±‚å‚æ•°
            params = {
                "accessToken": self.access_token,
                "fileId": file_id,
                "projectId": self.project_id
            }

            headers = {
                "User-Agent": "SafetyHelmetMonitor/1.0"
            }

            # å‘é€DELETEè¯·æ±‚
            response = requests.delete(DELETE_FILE_URL, params=params, headers=headers, timeout=10)

            print(f"ğŸ“¥ åˆ é™¤æ–‡ä»¶å“åº”çŠ¶æ€ç : {response.status_code}")
            print(f"ğŸ“¥ åˆ é™¤æ–‡ä»¶å“åº”å†…å®¹: {response.text}")

            if response.status_code == 200:
                result = response.json()
                meta = result.get("meta", {})

                if meta.get("code") == 200:
                    logger.info(f"âœ… äº‘ç«¯æ–‡ä»¶åˆ é™¤æˆåŠŸ: {file_id}")
                    return True
                else:
                    error_msg = meta.get("message", "æœªçŸ¥é”™è¯¯")
                    error_code = meta.get("code")
                    logger.warning(f"âš ï¸ äº‘ç«¯æ–‡ä»¶åˆ é™¤å¤±è´¥ (code={error_code}): {error_msg}")
                    return False
            else:
                logger.warning(f"âš ï¸ åˆ é™¤è¯·æ±‚å¤±è´¥ï¼ŒçŠ¶æ€ç : {response.status_code}")
                return False

        except Exception as e:
            logger.error(f"âŒ åˆ é™¤äº‘ç«¯æ–‡ä»¶å¼‚å¸¸: {str(e)}")
            return False
```

#### æ ¸å¿ƒæ–¹æ³•
- `delete_cloud_file(file_id: str) -> bool`ï¼šé€šè¿‡HTTP DELETEè¯·æ±‚åˆ é™¤æŒ‡å®šIDçš„äº‘ç«¯æ–‡ä»¶ï¼Œè¿”å›åˆ é™¤ç»“æœ

### 2. è¯­éŸ³å‘Šè­¦ï¼ˆVoiceAlertï¼‰

é€šè¿‡äº‘å¹³å°æ¥å£å®ç°è¯­éŸ³å‘Šè­¦çš„ä¸‹å‘ä¸æ’­æ”¾åŠŸèƒ½ã€‚

#### å®Œæ•´ä»£ç å®ç°
```python
class VoiceAlert:
    """è¯­éŸ³å‘Šè­¦ç±» - ä½¿ç”¨äº‘å¹¿æ’­è¯­éŸ³ä¸‹å‘æ¥å£"""

    def __init__(self, access_token, device_serial):
        self.access_token = access_token
        self.device_serial = device_serial

    def send_voice_alert(self, voice_file_url: str, channel_no: int = 1) -> dict:
        """å‘é€è¯­éŸ³å‘Šè­¦"""
        if not voice_file_url:
            return {"error": "è¯­éŸ³æ–‡ä»¶URLæœªé…ç½®"}

        data = {
            "accessToken": self.access_token,
            "fileUrl": voice_file_url,
            "deviceSerial": self.device_serial,
            "channelNo": channel_no,

        }

        headers = {"Content-Type": "application/x-www-form-urlencoded"}

        try:
            logger.info(f"å‘é€è¯­éŸ³å‘Šè­¦: è®¾å¤‡{self.device_serial}, æ–‡ä»¶{voice_file_url[:50]}...")
            response = requests.post(VOICE_SEND_URL, data=data, headers=headers, timeout=15)
            response.raise_for_status()

            result = response.json()
            logger.info(f"è¯­éŸ³ä¸‹å‘å“åº”: {result}")
            return result

        except requests.exceptions.Timeout:
            return {"error": "è¯­éŸ³ä¸‹å‘è¯·æ±‚è¶…æ—¶", "code": "20008"}
        except Exception as e:
            return {"error": f"è¯­éŸ³ä¸‹å‘å¼‚å¸¸: {str(e)}", "code": "49999"}

    def play_alert_voice(self, voice_file_url: str = None):
        """æ’­æ”¾å‘Šè­¦è¯­éŸ³"""
        try:
            audio_url = voice_file_url or VOICE_FILE_URL
            if not audio_url:
                logger.error("è¯­éŸ³æ–‡ä»¶URLæœªé…ç½®")
                return False

            result = self.send_voice_alert(audio_url, CHANNEL_NO)

            if "error" in result:
                logger.error(f"è¯­éŸ³æ’­æŠ¥å¤±è´¥: {result['error']}")
                return False

            code = result.get("code")
            if code == "200":
                logger.info("è¯­éŸ³æ’­æŠ¥æˆåŠŸ")
                return True
            else:
                error_mapping = {
                    "10001": "æ–‡ä»¶URLæˆ–é€šé“å‚æ•°ä¸åˆæ³•",
                    "20002": "è®¾å¤‡ä¸å­˜åœ¨",
                    "10031": "æƒé™ä¸è¶³",
                    "20018": "ç”¨æˆ·ä¸æ‹¥æœ‰è¯¥è®¾å¤‡",
                    "20007": "è®¾å¤‡ä¸åœ¨çº¿",
                    "20008": "è®¾å¤‡å“åº”è¶…æ—¶",
                    "20001": "é€šé“ä¸å­˜åœ¨",
                    "20015": "è®¾å¤‡ä¸æ”¯æŒå¯¹è®²",
                    "111000": "èµ„æºåŒ…ä½™é‡ä¸è¶³",
                }
                error_msg = error_mapping.get(code, f"æœªçŸ¥é”™è¯¯ç : {code}")
                logger.error(f"è¯­éŸ³æ’­æŠ¥å¤±è´¥: {error_msg}")
                return False

        except Exception as e:
            logger.error(f"è¯­éŸ³æ’­æŠ¥å¼‚å¸¸: {str(e)}")
            return False
```

#### æ ¸å¿ƒæ–¹æ³•
- `send_voice_alert(voice_file_url: str, channel_no: int = 1) -> dict`ï¼šå‘é€è¯­éŸ³å‘Šè­¦è¯·æ±‚åˆ°æŒ‡å®šè®¾å¤‡é€šé“
- `play_alert_voice(voice_file_url: str = None) -> bool`ï¼šå°è£…è¯­éŸ³æ’­æ”¾é€»è¾‘ï¼Œå¤„ç†é”™è¯¯ç æ˜ å°„ä¸ç»“æœåˆ¤æ–­

### 3. çœŸå®æµç¨‹æµ‹è¯•å™¨ï¼ˆRealProcessTesterï¼‰

ç³»ç»Ÿæ ¸å¿ƒæ¨¡å—ï¼Œåè°ƒå„åŠŸèƒ½æ¨¡å—å®Œæˆç«¯åˆ°ç«¯çš„æµ‹è¯•æµç¨‹ã€‚

#### å®Œæ•´ä»£ç å®ç°
```python
class RealProcessTester:
    """çœŸå®æµç¨‹æµ‹è¯•å™¨ - é›†æˆäº‘ç«¯å›¾ç‰‡æ¸…ç†åŠŸèƒ½"""

    def __init__(self):
        print("ğŸš€ åˆå§‹åŒ–çœŸå®æµç¨‹æµ‹è¯•å™¨...")

        # éªŒè¯å¿…è¦é…ç½®
        if not all([YS_ACCESS_TOKEN, DEVICE_SERIAL, PROJECT_ID]):
            missing = []
            if not YS_ACCESS_TOKEN: missing.append("YS_ACCESS_TOKEN")
            if not DEVICE_SERIAL: missing.append("DEVICE_SERIAL")
            if not PROJECT_ID: missing.append("CAPTURE_PROJECT_ID")
            raise ValueError(f"âŒ ç¼ºå°‘å¿…è¦é…ç½®: {', '.join(missing)}")

        # å­˜å‚¨é…ç½®
        self.storage_base_path = os.getenv("STORAGE_BASE_PATH", "./real_capture_images")
        if not os.path.exists(self.storage_base_path):
            os.makedirs(self.storage_base_path)

        # å‘Šè­¦é…ç½®
        self.alert_threshold = int(os.getenv("ALERT_THRESHOLD", "1"))

        # åˆå§‹åŒ–æœåŠ¡æ¨¡å—
        self.voice_alert = VoiceAlert(YS_ACCESS_TOKEN, DEVICE_SERIAL)
        self.cloud_manager = CloudFileManager(YS_ACCESS_TOKEN, PROJECT_ID)

        # æµ‹è¯•ç»“æœè®°å½•
        self.test_results = {
            "start_time": datetime.now(),
            "steps": [],
            "success": False,
            "end_time": None,
            "duration": 0,
            "detection_result": {},
            "alert_triggered": False,
            "cloud_file_cleaned": False
        }

        print(f"ğŸ”§ é…ç½®ä¿¡æ¯:")
        print(f"   è®¾å¤‡åºåˆ—å·: {DEVICE_SERIAL}")
        print(f"   é€šé“å·: {CHANNEL_NO}")
        print(f"   é¡¹ç›®ID: {PROJECT_ID}")
        print(f"   äº‘ç«¯æ¸…ç†: {'å¯ç”¨' if ENABLE_CLOUD_CLEANUP else 'ç¦ç”¨'}")

    def log_step(self, step_name: str, success: bool, details: str = ""):
        """è®°å½•æµ‹è¯•æ­¥éª¤"""
        step_record = {
            "name": step_name,
            "success": success,
            "details": details,
            "timestamp": datetime.now().isoformat()
        }
        self.test_results["steps"].append(step_record)

        status = "âœ…" if success else "âŒ"
        print(f"{status} {step_name}: {details}")

    def cloud_capture_sync(self):
        """åŒæ­¥äº‘æŠ“æ‹"""
        print("\n1. æ‰§è¡ŒåŒæ­¥äº‘æŠ“æ‹...")
        try:
            file_id = f"capture_{datetime.now().strftime('%Y%m%d_%H%M%S')}"

            data = {
                "accessToken": YS_ACCESS_TOKEN,
                "channelNo": str(CHANNEL_NO),
                "deviceSerial": DEVICE_SERIAL,
                "fileId": file_id,
                "projectId": PROJECT_ID,
                "captureType": "1"
            }

            headers = {
                "accessToken": YS_ACCESS_TOKEN,
                "Content-Type": "application/x-www-form-urlencoded"
            }

            response = requests.post(CAPTURE_URL, data=data, headers=headers, timeout=30)
            print(f"ğŸ“¥ æŠ“æ‹å“åº”: {response.status_code}")

            result = response.json()
            meta = result.get("meta", {})

            if meta.get("code") == 200:
                image_url = result.get("data", "")

                if image_url and image_url.startswith("http"):
                    self.log_step("åŒæ­¥äº‘æŠ“æ‹", True, f"æŠ“æ‹æˆåŠŸ")
                    return {
                        "success": True,
                        "image_url": image_url,
                        "file_id": file_id,
                        "timestamp": datetime.now(),
                        "device_serial": DEVICE_SERIAL,
                        "channel_no": CHANNEL_NO
                    }
                else:
                    self.log_step("åŒæ­¥äº‘æŠ“æ‹", False, f"å›¾ç‰‡URLæ— æ•ˆ")
                    return None
            else:
                error_msg = meta.get("message", "æœªçŸ¥é”™è¯¯")
                self.log_step("åŒæ­¥äº‘æŠ“æ‹", False, f"APIé”™è¯¯: {error_msg}")
                return None

        except Exception as e:
            self.log_step("åŒæ­¥äº‘æŠ“æ‹", False, f"å¼‚å¸¸: {str(e)}")
            return None

    def ai_helmet_detection(self, image_url: str):
        """AIå®‰å…¨å¸½è¯†åˆ«"""
        print("\n2. æ‰§è¡ŒAIå®‰å…¨å¸½è¯†åˆ«...")
        try:
            headers = {
                "accessToken": YS_ACCESS_TOKEN,
                "Content-Type": "application/json"
            }

            request_body = {
                "stream": False,
                "dataInfo": [{"data": image_url, "type": "url", "modal": "image"}],
                "dataParams": [{"modal": "image", "img_width": 1280, "img_height": 720}]
            }

            response = requests.post(HELMET_DETECT_URL, headers=headers, json=request_body, timeout=20)
            result = response.json()
            meta = result.get("meta", {})

            if meta.get("code") != 200:
                error_msg = meta.get("message", "æ— é”™è¯¯æè¿°")
                raise ValueError(f"è¯†åˆ«æ¥å£é”™è¯¯: {error_msg}")

            data = result.get("data", {})
            images = data.get("images", [])

            if not images:
                detection_result = {
                    "person_count": 0, "unworn_count": 0, "worn_count": 0,
                    "conclusion": "æœªæ£€æµ‹åˆ°äººå‘˜", "is_alert": False
                }
                self.log_step("AIå®‰å…¨å¸½è¯†åˆ«", True, "æœªæ£€æµ‹åˆ°äººå‘˜")
                return detection_result

            content_ann = images[0].get("contentAnn", {})
            bboxes = content_ann.get("bboxes", [])
            person_count = len(bboxes)
            unworn_count = 0

            for bbox in bboxes:
                tag_info = bbox.get("tagInfo", {})
                labels = tag_info.get("labels", [])
                for label in labels:
                    if label.get("key") == "category" and label.get("label") == "no":
                        unworn_count += 1
                        break

            worn_count = person_count - unworn_count
            is_alert = unworn_count > 0
            conclusion = "å­˜åœ¨æœªä½©æˆ´å®‰å…¨å¸½æƒ…å†µ" if is_alert else "å®‰å…¨çŠ¶æ€"

            detection_result = {
                "person_count": person_count, "unworn_count": unworn_count,
                "worn_count": worn_count, "conclusion": conclusion, "is_alert": is_alert
            }

            self.log_step("AIå®‰å…¨å¸½è¯†åˆ«", True, f"è¯†åˆ«å®Œæˆ: {person_count}äºº, æœªä½©æˆ´: {unworn_count}äºº")
            return detection_result

        except Exception as e:
            self.log_step("AIå®‰å…¨å¸½è¯†åˆ«", False, f"å¼‚å¸¸: {str(e)}")
            return None

    def download_and_save_image(self, image_url: str, capture_result: dict, detection_result: dict):
        """ä¸‹è½½å›¾ç‰‡å¹¶ä¿å­˜è¯†åˆ«ç»“æœ"""
        print("\n3. ä¸‹è½½å›¾ç‰‡å¹¶ä¿å­˜ç»“æœ...")
        try:
            date_folder = datetime.now().strftime("%Y-%m-%d")
            date_folder_path = os.path.join(self.storage_base_path, date_folder)
            if not os.path.exists(date_folder_path):
                os.makedirs(date_folder_path)

            filename = f"capture_{capture_result['timestamp'].strftime('%H%M%S')}.jpg"
            file_path = os.path.join(date_folder_path, filename)

            response = requests.get(image_url, timeout=30)
            response.raise_for_status()

            with open(file_path, 'wb') as f:
                f.write(response.content)

            result_filename = f"result_{capture_result['timestamp'].strftime('%H%M%S')}.json"
            result_path = os.path.join(date_folder_path, result_filename)

            result_data = {
                "capture_info": {**capture_result, "timestamp": capture_result["timestamp"].isoformat()},
                "detection_result": detection_result,
                "storage_info": {
                    "image_path": file_path, "result_path": result_path,
                    "saved_time": datetime.now().isoformat()
                }
            }

            with open(result_path, 'w', encoding='utf-8') as f:
                json.dump(result_data, f, indent=2, ensure_ascii=False)

            self.log_step("ä¸‹è½½ä¿å­˜", True, "å›¾ç‰‡å’Œç»“æœä¿å­˜æˆåŠŸ")
            return file_path, result_path

        except Exception as e:
            self.log_step("ä¸‹è½½ä¿å­˜", False, f"å¼‚å¸¸: {str(e)}")
            return None, None

    def check_alert_condition(self, detection_result: dict):
        """æ£€æŸ¥å‘Šè­¦æ¡ä»¶"""
        print("\n4. æ£€æŸ¥å‘Šè­¦æ¡ä»¶...")
        try:
            unworn_count = detection_result.get("unworn_count", 0)
            should_alert = unworn_count >= self.alert_threshold
            self.log_step("å‘Šè­¦æ£€æŸ¥", True, f"æœªä½©æˆ´: {unworn_count}, éœ€è¦å‘Šè­¦: {'æ˜¯' if should_alert else 'å¦'}")
            return should_alert
        except Exception as e:
            self.log_step("å‘Šè­¦æ£€æŸ¥", False, f"å¼‚å¸¸: {str(e)}")
            return False

    def play_voice_alert(self):
        """æ’­æ”¾è¯­éŸ³å‘Šè­¦"""
        print("\n5. æ’­æ”¾è¯­éŸ³å‘Šè­¦...")
        try:
            if not VOICE_FILE_URL:
                self.log_step("è¯­éŸ³å‘Šè­¦", False, "è¯­éŸ³æ–‡ä»¶URLæœªé…ç½®")
                return False

            voice_success = self.voice_alert.play_alert_voice(VOICE_FILE_URL)

            if voice_success:
                self.log_step("è¯­éŸ³å‘Šè­¦", True, "å‘Šè­¦æ’­æŠ¥æˆåŠŸ")
                return True
            else:
                self.log_step("è¯­éŸ³å‘Šè­¦", False, "è¯­éŸ³æ’­æŠ¥å¤±è´¥")
                return False

        except Exception as e:
            self.log_step("è¯­éŸ³å‘Šè­¦", False, f"å¼‚å¸¸: {str(e)}")
            return False

    def cleanup_cloud_file(self, file_id: str, detection_result: dict):
        """æ¸…ç†äº‘ç«¯æ–‡ä»¶ - å¦‚æœä¸æ˜¯å‘Šè­¦å›¾ç‰‡åˆ™åˆ é™¤"""
        print("\n6. æ£€æŸ¥äº‘ç«¯æ–‡ä»¶æ¸…ç†...")

        if not ENABLE_CLOUD_CLEANUP:
            self.log_step("äº‘ç«¯æ¸…ç†", True, "åŠŸèƒ½å·²ç¦ç”¨ï¼Œè·³è¿‡æ¸…ç†")
            return False

        try:
            is_alert = detection_result.get("is_alert", False)
            unworn_count = detection_result.get("unworn_count", 0)

            if not is_alert and unworn_count == 0:
                # éå‘Šè­¦å›¾ç‰‡ï¼Œæ‰§è¡Œæ¸…ç†
                cleanup_success = self.cloud_manager.delete_cloud_file(file_id)

                if cleanup_success:
                    self.log_step("äº‘ç«¯æ¸…ç†", True, "éå‘Šè­¦å›¾ç‰‡å·²ä»äº‘ç«¯åˆ é™¤")
                    self.test_results["cloud_file_cleaned"] = True
                    return True
                else:
                    self.log_step("äº‘ç«¯æ¸…ç†", False, "äº‘ç«¯æ–‡ä»¶åˆ é™¤å¤±è´¥")
                    return False
            else:
                # å‘Šè­¦å›¾ç‰‡ï¼Œä¿ç•™åœ¨äº‘ç«¯
                alert_reason = "å­˜åœ¨æœªä½©æˆ´å®‰å…¨å¸½" if is_alert else "æ£€æµ‹åˆ°äººå‘˜ä½†æ— éœ€å‘Šè­¦"
                self.log_step("äº‘ç«¯æ¸…ç†", True, f"å‘Šè­¦å›¾ç‰‡ä¿ç•™åœ¨äº‘ç«¯: {alert_reason}")
                return True

        except Exception as e:
            self.log_step("äº‘ç«¯æ¸…ç†", False, f"å¼‚å¸¸: {str(e)}")
            return False

    def run_real_process_test(self):
        """è¿è¡ŒçœŸå®æµç¨‹æµ‹è¯•"""
        print("=" * 60)
        print("ğŸš€ å¼€å§‹çœŸå®æµç¨‹æµ‹è¯•ï¼ˆé›†æˆäº‘ç«¯æ¸…ç†ï¼‰")
        print("=" * 60)
        print(f"æµ‹è¯•æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"è®¾å¤‡: {DEVICE_SERIAL}, é€šé“: {CHANNEL_NO}")
        print(f"å‘Šè­¦é˜ˆå€¼: {self.alert_threshold}äºº, äº‘ç«¯æ¸…ç†: {'å¯ç”¨' if ENABLE_CLOUD_CLEANUP else 'ç¦ç”¨'}")
        print("=" * 60)

        try:
            # æ­¥éª¤1: åŒæ­¥äº‘æŠ“æ‹
            capture_result = self.cloud_capture_sync()
            if not capture_result:
                self.finalize_test(False)
                return self.test_results

            # æ­¥éª¤2: AIå®‰å…¨å¸½è¯†åˆ«
            detection_result = self.ai_helmet_detection(capture_result["image_url"])
            if not detection_result:
                self.finalize_test(False)
                return self.test_results

            # æ­¥éª¤3: ä¸‹è½½å›¾ç‰‡å¹¶ä¿å­˜ç»“æœ
            self.download_and_save_image(capture_result["image_url"], capture_result, detection_result)

            # æ­¥éª¤4: æ£€æŸ¥å‘Šè­¦å¹¶æ’­æ”¾è¯­éŸ³
            should_alert = self.check_alert_condition(detection_result)
            if should_alert:
                self.play_voice_alert()
            else:
                self.log_step("è¯­éŸ³å‘Šè­¦", True, "æ— éœ€å‘Šè­¦ï¼Œè·³è¿‡æ’­æŠ¥")

            # æ­¥éª¤5: äº‘ç«¯æ–‡ä»¶æ¸…ç†ï¼ˆå¦‚æœä¸æ˜¯å‘Šè­¦å›¾ç‰‡ï¼‰
            self.cleanup_cloud_file(capture_result["file_id"], detection_result)

            # æ€»ç»“æµ‹è¯•ç»“æœ
            self.finalize_test(True, detection_result, should_alert)
            return self.test_results

        except Exception as e:
            logger.error(f"æµ‹è¯•è¿‡ç¨‹å¼‚å¸¸: {str(e)}")
            self.finalize_test(False)
            return self.test_results

    def finalize_test(self, success: bool, detection_result: dict = None, alert_triggered: bool = False):
        """æœ€ç»ˆåŒ–æµ‹è¯•ç»“æœ"""
        self.test_results["success"] = success and all(step["success"] for step in self.test_results["steps"])
        self.test_results["end_time"] = datetime.now()
        self.test_results["duration"] = (
                    self.test_results["end_time"] - self.test_results["start_time"]).total_seconds()

        if detection_result:
            self.test_results["detection_result"] = detection_result
            self.test_results["alert_triggered"] = alert_triggered

        self.print_test_summary()

    def print_test_summary(self):
        """æ‰“å°æµ‹è¯•æ€»ç»“"""
        print("\n" + "=" * 60)
        print("ğŸ“Š çœŸå®æµç¨‹æµ‹è¯•æ€»ç»“")
        print("=" * 60)

        total_steps = len(self.test_results["steps"])
        successful_steps = sum(1 for step in self.test_results["steps"] if step["success"])

        print(
            f"æµ‹è¯•æ—¶é—´: {self.test_results['start_time'].strftime('%H:%M:%S')} - {self.test_results['end_time'].strftime('%H:%M:%S')}")
        print(f"æ€»è€—æ—¶: {self.test_results['duration']:.2f}ç§’")
        print(f"æ­¥éª¤å®Œæˆ: {successful_steps}/{total_steps}")
        print(f"æ•´ä½“ç»“æœ: {'âœ… æˆåŠŸ' if self.test_results['success'] else 'âŒ å¤±è´¥'}")

        if 'detection_result' in self.test_results:
            dr = self.test_results['detection_result']
            print(f"\nè¯†åˆ«ç»“æœ:")
            print(f"  æ€»äººæ•°: {dr.get('person_count', 0)}")
            print(f"  æœªä½©æˆ´: {dr.get('unworn_count', 0)}")
            print(f"  ç»“è®º: {dr.get('conclusion', 'æœªçŸ¥')}")
            print(f"  å‘Šè­¦è§¦å‘: {'æ˜¯' if self.test_results['alert_triggered'] else 'å¦'}")
            print(f"  äº‘ç«¯æ¸…ç†: {'æ˜¯' if self.test_results.get('cloud_file_cleaned') else 'å¦'}")

        if self.test_results["success"]:
            print("\nğŸ‰ æµ‹è¯•é€šè¿‡ï¼ç³»ç»ŸåŠŸèƒ½æ­£å¸¸ã€‚")
        else:
            print("\nâš ï¸ å¤±è´¥çš„æ­¥éª¤:")
            for step in self.test_results["steps"]:
                if not step["success"]:
                    print(f"  - {step['name']}: {step['details']}")

        print("=" * 60)
```

#### ä¸»å‡½æ•°å®ç°
```python
def main():
    """ä¸»å‡½æ•°"""
    try:
        # æ£€æŸ¥å¿…è¦é…ç½®
        required_env_vars = ["YS_ACCESS_TOKEN", "DEVICE_SERIAL", "CAPTURE_PROJECT_ID"]
        missing_vars = [var for var in required_env_vars if not os.getenv(var)]

        if missing_vars:
            print(f"âŒ ç¼ºå°‘é…ç½®: {', '.join(missing_vars)}")
            return

        # è¿è¡Œæµ‹è¯•
        tester = RealProcessTester()
        results = tester.run_real_process_test()

        # ä¿å­˜ç»“æœ
        if results["end_time"]:
            results_file = f"test_results_{results['start_time'].strftime('%Y%m%d_%H%M%S')}.json"
            with open(results_file, 'w', encoding='utf-8') as f:
                serializable_results = results.copy()
                serializable_results["start_time"] = serializable_results["start_time"].isoformat()
                serializable_results["end_time"] = serializable_results["end_time"].isoformat()
                json.dump(serializable_results, f, indent=2, ensure_ascii=False)

            print(f"\nğŸ“„ ç»“æœå·²ä¿å­˜: {results_file}")

    except Exception as e:
        print(f"âŒ æµ‹è¯•å¤±è´¥: {str(e)}")


if __name__ == "__main__":
    main()
```

#### æ ¸å¿ƒåŠŸèƒ½
- ç³»ç»Ÿåˆå§‹åŒ–ä¸é…ç½®éªŒè¯
- å®Œæ•´æµ‹è¯•æµç¨‹æ§åˆ¶ï¼ˆæŠ“æ‹â†’è¯†åˆ«â†’å­˜å‚¨â†’å‘Šè­¦â†’æ¸…ç†ï¼‰
- æµ‹è¯•æ­¥éª¤è®°å½•ä¸ç»“æœæ±‡æ€»
- è¯¦ç»†çš„æµ‹è¯•æ€»ç»“ä¸æŠ¥å‘Šç”Ÿæˆ

## ç³»ç»Ÿå·¥ä½œæµç¨‹

1. **åˆå§‹åŒ–é˜¶æ®µ**
   ```python
   # åˆå§‹åŒ–æµ‹è¯•å™¨
   tester = RealProcessTester()
   # éªŒè¯é…ç½®å¹¶åˆå§‹åŒ–ä¾èµ–ç»„ä»¶
   ```

2. **äº‘æŠ“æ‹é˜¶æ®µ**
   ```python
   # è°ƒç”¨äº‘æŠ“æ‹æ¥å£
   capture_result = self.cloud_capture_sync()
   # è·å–å›¾ç‰‡URLå’Œæ–‡ä»¶ID
   ```

3. **AIè¯†åˆ«é˜¶æ®µ**
   ```python
   # æäº¤å›¾ç‰‡URLè‡³AIè¯†åˆ«æ¥å£
   detection_result = self.ai_helmet_detection(capture_result["image_url"])
   # åˆ†æäººå‘˜å®‰å…¨å¸½ä½©æˆ´æƒ…å†µ
   ```

4. **æœ¬åœ°å­˜å‚¨é˜¶æ®µ**
   ```python
   # ä¸‹è½½å›¾ç‰‡å¹¶ä¿å­˜è¯†åˆ«ç»“æœ
   self.download_and_save_image(capture_result["image_url"], capture_result, detection_result)
   # æŒ‰æ—¥æœŸåˆ†ç±»å­˜å‚¨å›¾ç‰‡å’ŒJSONç»“æœ
   ```

5. **å‘Šè­¦åˆ¤æ–­é˜¶æ®µ**
   ```python
   # æ¯”è¾ƒæœªä½©æˆ´äººæ•°ä¸é˜ˆå€¼
   should_alert = self.check_alert_condition(detection_result)
   ```

6. **è¯­éŸ³å‘Šè­¦é˜¶æ®µ**
   ```python
   # è§¦å‘è¯­éŸ³å‘Šè­¦
   if should_alert:
       self.play_voice_alert()
   ```

7. **äº‘ç«¯æ¸…ç†é˜¶æ®µ**
   ```python
   # æ¸…ç†éå‘Šè­¦å›¾ç‰‡
   self.cleanup_cloud_file(capture_result["file_id"], detection_result)
   ```

8. **ç»“æœæ±‡æ€»é˜¶æ®µ**
   ```python
   # ç”Ÿæˆå¹¶ä¿å­˜æµ‹è¯•æŠ¥å‘Š
   self.finalize_test(True, detection_result, should_alert)
   ```

## ç»“æœè¾“å‡º

1. **æ—¥å¿—è¾“å‡º**
   - æ§åˆ¶å°å®æ—¶è¾“å‡ºå„æ­¥éª¤çŠ¶æ€
   - æ—¥å¿—æ–‡ä»¶ `real_process_test.log` è®°å½•è¯¦ç»†æ“ä½œæ—¥å¿—

2. **æ•°æ®å­˜å‚¨**
   - æŠ“æ‹å›¾ç‰‡ï¼šæŒ‰æ—¥æœŸå­˜å‚¨äº `STORAGE_BASE_PATH` ç›®å½•ï¼ˆé»˜è®¤ `./real_capture_images`ï¼‰
   - è¯†åˆ«ç»“æœï¼šåŒç›®å½•ä¸‹çš„JSONæ–‡ä»¶ï¼ŒåŒ…å«å®Œæ•´æ£€æµ‹ä¿¡æ¯
   - æµ‹è¯•æŠ¥å‘Šï¼šä»¥ `test_results_<timestamp>.json` å‘½åçš„å®Œæ•´æµ‹è¯•ç»“æœ

3. **æ§åˆ¶å°æ€»ç»“**
   - æ˜¾ç¤ºæµ‹è¯•æ€»è€—æ—¶ã€æ­¥éª¤å®Œæˆæƒ…å†µ
   - å±•ç¤ºè¯†åˆ«ç»“æœï¼ˆæ€»äººæ•°ã€æœªä½©æˆ´äººæ•°ç­‰ï¼‰
   - æç¤ºå‘Šè­¦è§¦å‘çŠ¶æ€å’Œäº‘ç«¯æ¸…ç†ç»“æœ

## ä½¿ç”¨è¯´æ˜

1. **ç¯å¢ƒé…ç½®**
   - åˆ›å»º `.env` æ–‡ä»¶ï¼Œé…ç½®å¿…è¦å‚æ•°ï¼š
     ```
     YS_ACCESS_TOKEN=your_access_token
     DEVICE_SERIAL=your_device_serial
     CAPTURE_PROJECT_ID=your_project_id
     # å¯é€‰é…ç½®
     VOICE_FILE_URL=https://your-voice-file-url.mp3
     ENABLE_CLOUD_CLEANUP=true
     STORAGE_BASE_PATH=./images
     ALERT_THRESHOLD=1
     ```

2. **å®‰è£…ä¾èµ–**
   ```bash
   pip install requests python-dotenv
   ```

3. **è¿è¡Œç¨‹åº**
   ```bash
   python real_process_test_with_cleanup.py
   ```

4. **æŸ¥çœ‹ç»“æœ**
   - æ§åˆ¶å°æŸ¥çœ‹å®æ—¶è¿›åº¦å’Œæ€»ç»“
   - æ—¥å¿—æ–‡ä»¶æŸ¥çœ‹è¯¦ç»†è¿‡ç¨‹
   - ç»“æœæ–‡ä»¶å’Œå›¾ç‰‡å­˜å‚¨åœ¨é…ç½®çš„ç›®å½•ä¸­

## é”™è¯¯å¤„ç†

ç³»ç»Ÿå¯¹å„é˜¶æ®µå¯èƒ½å‡ºç°çš„å¼‚å¸¸è¿›è¡Œäº†å…¨é¢å¤„ç†ï¼Œä¸»è¦åŒ…æ‹¬ï¼š

1. **é…ç½®é”™è¯¯**
   - åˆå§‹åŒ–æ—¶æ£€æŸ¥å¿…è¦é…ç½®é¡¹ï¼Œç¼ºå¤±åˆ™ç»ˆæ­¢å¹¶æç¤º

2. **ç½‘ç»œå¼‚å¸¸**
   - æ‰€æœ‰APIè¯·æ±‚è®¾ç½®è¶…æ—¶æ—¶é—´
   - æ•è·ç½‘ç»œè¿æ¥é”™è¯¯å¹¶è®°å½•

3. **æ¥å£é”™è¯¯**
   - å¤„ç†HTTPçŠ¶æ€ç é200çš„æƒ…å†µ
   - è§£ææ¥å£è¿”å›çš„é”™è¯¯ç å’Œä¿¡æ¯

4. **æ–‡ä»¶æ“ä½œé”™è¯¯**
   - å¤„ç†å›¾ç‰‡ä¸‹è½½å’Œä¿å­˜å¼‚å¸¸
   - è‡ªåŠ¨åˆ›å»ºå­˜å‚¨ç›®å½•ï¼ˆå¦‚ä¸å­˜åœ¨ï¼‰

é”™è¯¯ä¿¡æ¯ä¼šåŒæ—¶è¾“å‡ºåˆ°æ§åˆ¶å°å’Œæ—¥å¿—æ–‡ä»¶ï¼Œæ ¼å¼ç»Ÿä¸€ä¸ºï¼š
```python
logger.error(f"âŒ é”™è¯¯æè¿°: {str(e)}")
```

